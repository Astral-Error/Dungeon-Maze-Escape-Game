# Dungeon-Maze-Escape-Game
This was made as an assignment project in my University (VIT). **VIT Registration Number: 24BCE0995**

# Explanation
The following program is a dungeon escape game designed entirely in python.
The modules used in the following program are:
-	Pygame
-	Random
-	Pyautogui

Whenever the program is run, it procedurally generates a maze for the user to navigate through. For every run of the program it generates a new and unique maze. The game begins with the player being at the top-most row indicated by a blue square and the exit is present at the bottom-most row which is indicated by a pale-yellow square. The black blocks in the window marks the walls or barriers of the maze while the white marks the empty spaces for the player to navigate through.
Moving on to the working of the program, we’ll be mainly discussing the significant methods that handle the game.
The first and foremost method called at the beginning of the program is the maze_generation() method.

- maze_generation(): This method generates of maze of random size ranging between a size of 30x40 to 40x50 square. The maze so generated and used throughout the program is implemented by using nested lists. This function further creates a pathway from the beginning till the end of the maze, which provides the player with at least one navigable way to the end. The algorithm which generates the maze is also randomized as it generates a gap in the adjacent row or column depend upon the number that is generated. For an even generated number it creates a gap in the adjacent row, however if it is an odd number the gap is created in an adjacent column. In the algorithm, it is taken care that the path is generated till the end and it doesn’t stop midway if it hits the end of one corner. For the formerly mentioned purpose it uses two flags flag_columnEnd and flag_columnBegin and two variables origin_row and origin_column to determine the position of the last created gap, while the flags are used to indicate whether the generating pathway has reached either lateral ends of the maze. This helps the algorithm to generate the path until the very end and not stop mid-way while also creating a bit of complexity in the navigable path to make it a challenge for the player to navigate. After the maze is generated the function returns it. The function also generates a random value i.e the index from which the player will begin navigating AKA the entry point of the maze, this is stored in entry_column.
  
Next in the main method the variable exit_pos is assigned with the value where the exit is present, it is simply done by accessing the index of the space present in the last row of the maze.
The next method invoked is the maze_config() method.
- maze_config(): This method takes the maze previously generated by the maze_generation() method and randomly throws in space in the maze, to create a sense of confusion as to which might be the actual navigable path.

Then a variable flag_firstMove is used to prevent the user from going “up” in the very first move as that would be an illegal move. Then we define the colors that are to be used to represent the various element in the game window.

Next, we move on to screen setup for the creation and manipulation of the game window.

We use the set_mode() attribute of the display function in the pygame module to create the screen for drawing the elements upon. We use the set_caption() attribute of the display function of pygame module for defining the title of the game window. The clock variable is used to regulate the refresh rate of the game, it is implemented using the clock() attribute of the time function of pygame module.

We use the alert() function of pyautogui module to generate a alert/message box which greets the user with the basic info about the game and its controls. 

Then we run a while loop which is used to update the game screen every time the player makes a move and it is also used for event handling.

We use a flag named quit_flag to determine whether the user completed the game or exited mid-way, this is done in order to display a congratulations message if the user successfully completes the game.

screen.fill(white) is used to fill the screen with white every time before updating the output, so as in order to avoid ghosting due to the previously generated frame, this helps us creates a smooth and seamless animation for the user. 

We use the get() attribute of the event method of pygame module for event capturing. Furthermore, we use the type() attribute to verify the type of the event occurring, for this use case we need only two type that is pygame.QUIT and pygame.KEYDOWN, the former referring to the player hitting the cross button in the title bar to exit the game and the later referring to event where any key on the keyboard is pressed.

Then we use the key() attribute to determine the specific keydown event as to which key is pressed by the user and if it is among the four valid control keys i.e up, down, left or right, then the move is made accordingly and the screen is updated. During this segment of the program the user-defined function player_movement() is referred which is discussed in the later half of this documentation.

Then the draw_maze() function is called to draw the maze with the provided data of the element and their locations on the map. 

Then the flip() attribute of the display function of pygame module is used to flip the display. Now what this does it unless and until the flip() attribute is called the screen is generated with the required values and everything but it won’t be displayed to the user unless and until it’s flipped.

The tick() function is used to regulate the framerate of the game.

Finally, the pygame.quit() method is used to quit the game.

As mentioned earlier, here is an explanation of the player_movement() function.
- player_movement(): This function takes the player move in form of a string as a positional argument. The function first gets the player position user the position() function, which is another user-defined function to get the current position of the player in the maze, it returns the row and column as a list. Depending upon the move executed, the player_movement() function calls the respective move function which can be move_up(), move_down(), move_left() or move_right(). Each of these functions have nearly the same working principle and what they perform is they take the current move and adjust the position of the player based on the current position and the move executed and returns the new position or an error message if it is an illegal move.

Once we have the data from any of the move function executed, we proceed to call the update_maze() function which takes the new value of the row and column i.e the location of the player in the maze and updates the maze accordingly.
That should pretty much explain about the entire working of this maze game.
